<?php

class TokenGenerator {

  /**
   * Additional salt to add more entropy when the tokens are stored as hashes.
   * 
   * @var string
   */
  protected $salt = "";

  function __construct($salt = "") {
    $this->salt = $salt;
  }

  /**
   * Create a pseudo-random token.
   *
   * The token is pseudo-random. If you need better security, read from /dev/urandom
   */
  public function generate() {
    return md5(uniqid(mt_rand(), true));
  }
  
  public function generateJWT($email, $roles = "shopper") {
    // base64 encodes the header json
    $encoded_header = base64_encode('{"alg": "HS256","typ": "JWT"}');
    
    // base64 encodes the payload json
    $encoded_payload = base64_encode('{"email": "'.$email.'","roles":"'.$roles.'"}');
    
    // base64 strings are concatenated to one that looks like this
    $header_payload = $encoded_header . '.' . $encoded_payload;
    
    // Creating the signature, a hash with the s256 algorithm and the secret key. The signature is also base64 encoded.
    $signature = base64_encode(hash_hmac('sha256', $header_payload, $this->salt, true));
    
    // Creating the JWT token by concatenating the signature with the header and payload, that looks like this:
    $jwt_token = $header_payload . '.' . $signature;
    
    return $jwt_token;
  }
  
  public function verify($recievedJwt) {
    //VERIFY
    //$recievedJwt = 'eyJhbGciOiAiSFMyNTYiLCJ0eXAiOiAiSldUIn0=.eyJjb3VudHJ5IjogIlJvbWFuaWEiLCJuYW1lIjogIk9jdGF2aWEgQW5naGVsIiwiZW1haWwiOiAib2N0YXZpYWFuZ2hlbEBnbWFpbC5jb20ifQ==.gbB+B063g+kwsoc4L3B1Bu2wM+VEBElwPiLOb0fj2SE=';
    
    //$secret_key = 'Octaviasecretkey';
    
    // Split a string by '.'
    $jwt_values = explode('.', $recievedJwt);
    
    // extracting the signature from the original JWT
    $recieved_signature = $jwt_values [2];
    
    // concatenating the first two arguments of the $jwt_values array, representing the header and the payload
    $recievedHeaderAndPayload = $jwt_values [0] . '.' . $jwt_values [1];
    
    // creating the Base 64 encoded new signature generated by applying the HMAC method to the concatenated header and payload values
    $resultedsignature = base64_encode(hash_hmac('sha256', $recievedHeaderAndPayload, $this->salt, true));
    
    // checking if the created signature is equal to the received signature
    if ($resultedsignature == $recieved_signature) {
      
      // If everything worked fine, if the signature is ok and the payload was not modified you should get a success message
      return true;
    }
    
    return false;
  }

  /**
   *
   * @return string
   */
  public function getSalt() {
    return $this->salt;
  }

  /**
   * The salt is additional information that is added to the tokens to make
   * them more unqiue and secure.
   * The salt is not stored in the cookie and
   * should not saved in the storage.
   *
   * For example, to bind a token to an IP address use $_SERVER['REMOTE_ADDR'].
   * To bind a token to the browser (user agent), use $_SERVER['HTTP_USER_AGENT].
   * You could also use a long random string that is uniqe to your application.
   * 
   * @param string $salt          
   */
  public function setSalt($salt) {
    $this->salt = $salt;
  }
}
